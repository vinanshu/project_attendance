import{a as ce}from"./chunk-4ZP5PNUC.js";import{e as ve,h as _e,i as re,j as ne,k as oe,l as ae,m as le,n as Te,o as J,p as Fe,q as ue,r as de,s as pe,t as fe,u as Re,v as Me}from"./chunk-JSQ47LU7.js";import{a as Se,b as me,c as j,d as P,e as V}from"./chunk-GMYUOGPV.js";import"./chunk-PZ27VTCT.js";import{c as Pe,d as n,e as p,f as y,g as I,i as f}from"./chunk-MPW3RCU6.js";f();f();f();var ke=new Error("timeout while waiting for mutex to become available"),Ge=new Error("mutex already locked"),Oe=new Error("request for lock canceled"),De=function(i,t,e,s){function o(r){return r instanceof e?r:new e(function(c){c(r)})}return new(e||(e=Promise))(function(r,c){function m(u){try{d(s.next(u))}catch(a){c(a)}}function l(u){try{d(s.throw(u))}catch(a){c(a)}}function d(u){u.done?r(u.value):o(u.value).then(m,l)}d((s=s.apply(i,t||[])).next())})},Z=class{constructor(t,e=Oe){this._value=t,this._cancelError=e,this._weightedQueues=[],this._weightedWaiters=[]}acquire(t=1){if(t<=0)throw new Error(`invalid weight ${t}: must be positive`);return new Promise((e,s)=>{this._weightedQueues[t-1]||(this._weightedQueues[t-1]=[]),this._weightedQueues[t-1].push({resolve:e,reject:s}),this._dispatch()})}runExclusive(t,e=1){return De(this,void 0,void 0,function*(){let[s,o]=yield this.acquire(e);try{return yield t(s)}finally{o()}})}waitForUnlock(t=1){if(t<=0)throw new Error(`invalid weight ${t}: must be positive`);return new Promise(e=>{this._weightedWaiters[t-1]||(this._weightedWaiters[t-1]=[]),this._weightedWaiters[t-1].push(e),this._dispatch()})}isLocked(){return this._value<=0}getValue(){return this._value}setValue(t){this._value=t,this._dispatch()}release(t=1){if(t<=0)throw new Error(`invalid weight ${t}: must be positive`);this._value+=t,this._dispatch()}cancel(){this._weightedQueues.forEach(t=>t.forEach(e=>e.reject(this._cancelError))),this._weightedQueues=[]}_dispatch(){var t;for(let e=this._value;e>0;e--){let s=(t=this._weightedQueues[e-1])===null||t===void 0?void 0:t.shift();if(!s)continue;let o=this._value,r=e;this._value-=e,e=this._value+1,s.resolve([o,this._newReleaser(r)])}this._drainUnlockWaiters()}_newReleaser(t){let e=!1;return()=>{e||(e=!0,this.release(t))}}_drainUnlockWaiters(){for(let t=this._value;t>0;t--)this._weightedWaiters[t-1]&&(this._weightedWaiters[t-1].forEach(e=>e()),this._weightedWaiters[t-1]=[])}},Ae=function(i,t,e,s){function o(r){return r instanceof e?r:new e(function(c){c(r)})}return new(e||(e=Promise))(function(r,c){function m(u){try{d(s.next(u))}catch(a){c(a)}}function l(u){try{d(s.throw(u))}catch(a){c(a)}}function d(u){u.done?r(u.value):o(u.value).then(m,l)}d((s=s.apply(i,t||[])).next())})},R=class{constructor(t){this._semaphore=new Z(1,t)}acquire(){return Ae(this,void 0,void 0,function*(){let[,t]=yield this._semaphore.acquire();return t})}runExclusive(t){return this._semaphore.runExclusive(()=>t())}isLocked(){return this._semaphore.isLocked()}waitForUnlock(){return this._semaphore.waitForUnlock()}release(){this._semaphore.isLocked()&&this._semaphore.release()}cancel(){return this._semaphore.cancel()}};f();var ye=Pe(Se(),1);async function ee(i){if(ue){let t=await import("fs"),e=await import("zlib"),{Writable:s}=await import("stream"),{pipeline:o}=await import("stream/promises");if(!t.existsSync(i))throw new Error(`Extension bundle not found: ${i}`);let r=e.createGunzip(),c=[];return await o(t.createReadStream(i),r,new s({write(m,l,d){c.push(m),d()}})),new Blob(c)}else{let t=await fetch(i.toString());if(!t.ok||!t.body)return null;if(t.headers.get("Content-Encoding")==="gzip")return t.blob();{let e=new DecompressionStream("gzip");return new Response(t.body.pipeThrough(e)).blob()}}}async function he(i,t){for(let e in i.pg_extensions){let s;try{s=await i.pg_extensions[e]}catch(o){console.error("Failed to fetch extension:",e,o);continue}if(s){let o=new Uint8Array(await s.arrayBuffer());Ie(i,e,o,t)}else console.error("Could not get binary data for extension:",e)}}function Ie(i,t,e,s){ye.default.untar(e).forEach(r=>{if(!r.name.startsWith(".")){let c=i.WASM_PREFIX+"/"+r.name;if(r.name.endsWith(".so")){let m=(...d)=>{s("pgfs:ext OK",c,d)},l=(...d)=>{s("pgfs:ext FAIL",c,d)};i.FS.createPreloadedFile(Be(c),r.name.split("/").pop().slice(0,-3),r.data,!0,!0,m,l,!1)}else i.FS.writeFile(c,r.data)}})}function Be(i){let t=i.lastIndexOf("/");return t>0?i.slice(0,t):i}f();f();var q=class extends V{async init(t,e){return this.pg=t,{emscriptenOpts:{...e,preRun:[...e.preRun||[],o=>{let r=o.FS.filesystems.IDBFS;o.FS.mkdir("/pglite"),o.FS.mkdir(`/pglite/${this.dataDir}`),o.FS.mount(r,{},`/pglite/${this.dataDir}`),o.FS.symlink(`/pglite/${this.dataDir}`,P)}]}}}initialSyncFs(){return new Promise((t,e)=>{this.pg.Module.FS.syncfs(!0,s=>{s?e(s):t()})})}syncToFs(t){return new Promise((e,s)=>{this.pg.Module.FS.syncfs(!1,o=>{o?s(o):e()})})}async closeFs(){let t=this.pg.Module.FS.filesystems.IDBFS.dbs[this.dataDir];t&&t.close(),this.pg.Module.FS.quit()}};f();var L=class extends V{async closeFs(){this.pg.Module.FS.quit()}};function xe(i){let t;if(i?.startsWith("file://")){if(i=i.slice(7),!i)throw new Error("Invalid dataDir, must be a valid path");t="nodefs"}else i?.startsWith("idb://")?(i=i.slice(6),t="idbfs"):i?.startsWith("opfs-ahp://")?(i=i.slice(11),t="opfs-ahp"):!i||i?.startsWith("memory://")?t="memoryfs":t="nodefs";return{dataDir:i,fsType:t}}async function ge(i,t){let e;if(i&&t==="nodefs"){let{NodeFS:s}=await import("./fs/nodefs.js");e=new s(i)}else if(i&&t==="idbfs")e=new q(i);else if(i&&t==="opfs-ahp"){let{OpfsAhpFS:s}=await import("./fs/opfs-ahp.js");e=new s(i)}else e=new L;return e}f();import Ne from"./postgres.js";var we=Ne;var B,M,O,N,k,K,X,Y,G,z,$,C,D,T,g,A,E,Ee,W,te=class te extends ce{constructor(e={},s={}){super();p(this,E);p(this,B,!1);p(this,M,!1);p(this,O,!1);p(this,N,!1);p(this,k,!1);p(this,K,new R);p(this,X,new R);p(this,Y,new R);p(this,G,!1);this.debug=0;p(this,z);p(this,$,[]);p(this,C,new J);p(this,D);p(this,T);p(this,g,new Map);p(this,A,new Set);typeof e=="string"?s={dataDir:e,...s}:s=e,this.dataDir=s.dataDir,s.parsers!==void 0&&(this.parsers={...this.parsers,...s.parsers}),s.serializers!==void 0&&(this.serializers={...this.serializers,...s.serializers}),s?.debug!==void 0&&(this.debug=s.debug),s?.relaxedDurability!==void 0&&y(this,k,s.relaxedDurability),y(this,z,s.extensions??{}),this.waitReady=I(this,E,Ee).call(this,s??{})}static async create(e,s){let o=typeof e=="string"?{dataDir:e,...s??{}}:e??{},r=new te(o);return await r.waitReady,r}get Module(){return this.mod}get ready(){return n(this,B)&&!n(this,M)&&!n(this,O)}get closed(){return n(this,O)}async close(){await this._checkReady(),y(this,M,!0);for(let e of n(this,$))await e();try{await this.execProtocol(re.end()),this.mod._pg_shutdown()}catch(e){let s=e;if(!(s.name==="ExitStatus"&&s.status===0))throw e}await this.fs.closeFs(),y(this,O,!0),y(this,M,!1)}async[Symbol.asyncDispose](){await this.close()}async _handleBlob(e){y(this,D,e?await e.arrayBuffer():void 0)}async _cleanupBlob(){y(this,D,void 0)}async _getWrittenBlob(){if(!n(this,T))return;let e=new Blob(n(this,T));return y(this,T,void 0),e}async _checkReady(){if(n(this,M))throw new Error("PGlite is closing");if(n(this,O))throw new Error("PGlite is closed");n(this,B)||await this.waitReady}async execProtocolRaw(e,{syncToFs:s=!0}={}){let o=e.length,r=this.mod;r._interactive_write(o),r.HEAPU8.set(e,1),r._interactive_one();let c=o+2,m=c+r._interactive_read(),l=r.HEAPU8.subarray(c,m);return s&&await this.syncToFs(),l}async execProtocol(e,{syncToFs:s=!0,throwOnError:o=!0,onNotice:r}={}){let c=await this.execProtocolRaw(e,{syncToFs:s}),m=[];return n(this,C).parse(c,l=>{if(l instanceof ne){if(y(this,C,new J),o)throw l}else if(l instanceof le)this.debug>0&&console.warn(l),r&&r(l);else if(l instanceof ae)switch(l.text){case"BEGIN":y(this,N,!0);break;case"COMMIT":case"ROLLBACK":y(this,N,!1);break}else if(l instanceof oe){let d=n(this,g).get(l.channel);d&&d.forEach(u=>{queueMicrotask(()=>u(l.payload))}),n(this,A).forEach(u=>{queueMicrotask(()=>u(l.channel,l.payload))})}m.push(l)}),{messages:m,data:c}}isInTransaction(){return n(this,N)}async syncToFs(){if(n(this,G))return;y(this,G,!0);let e=async()=>{await n(this,Y).runExclusive(async()=>{y(this,G,!1),await this.fs.syncToFs(n(this,k))})};n(this,k)?e():await e()}async listen(e,s){return n(this,g).has(e)||n(this,g).set(e,new Set),n(this,g).get(e).add(s),await this.exec(`LISTEN "${e}"`),async()=>{await this.unlisten(e,s)}}async unlisten(e,s){s?(n(this,g).get(e)?.delete(s),n(this,g).get(e)?.size===0&&(await this.exec(`UNLISTEN "${e}"`),n(this,g).delete(e))):(await this.exec(`UNLISTEN "${e}"`),n(this,g).delete(e))}onNotification(e){return n(this,A).add(e),()=>{n(this,A).delete(e)}}offNotification(e){n(this,A).delete(e)}async dumpDataDir(e){let s=this.dataDir?.split("/").pop()??"pgdata";return this.fs.dumpTar(s,e)}_runExclusiveQuery(e){return n(this,K).runExclusive(e)}_runExclusiveTransaction(e){return n(this,X).runExclusive(e)}};B=new WeakMap,M=new WeakMap,O=new WeakMap,N=new WeakMap,k=new WeakMap,K=new WeakMap,X=new WeakMap,Y=new WeakMap,G=new WeakMap,z=new WeakMap,$=new WeakMap,C=new WeakMap,D=new WeakMap,T=new WeakMap,g=new WeakMap,A=new WeakMap,E=new WeakSet,Ee=async function(e){if(e.fs)this.fs=e.fs;else{let{dataDir:a,fsType:h}=xe(e.dataDir);this.fs=await ge(a,h)}let s={},o=[],r=[`PGDATA=${P}`,`PREFIX=${j}`,`PGUSER=${e.username??"postgres"}`,`PGDATABASE=${e.database??"template1"}`,"MODE=REACT","REPL=N",...this.debug?["-d",this.debug.toString()]:[]];e.wasmModule||de();let c=e.fsBundle?e.fsBundle.arrayBuffer():fe(),m;c.then(a=>{m=a});let l={WASM_PREFIX:j,arguments:r,INITIAL_MEMORY:e.initialMemory,noExitRuntime:!0,...this.debug>0?{print:console.info,printErr:console.error}:{print:()=>{},printErr:()=>{}},instantiateWasm:(a,h)=>(pe(a,e.wasmModule).then(({instance:x,module:w})=>{h(x,w)}),{}),getPreloadedPackage:(a,h)=>{if(a==="postgres.data"){if(m.byteLength!==h)throw new Error(`Invalid FS bundle size: ${m.byteLength} !== ${h}`);return m}throw new Error(`Unknown package: ${a}`)},preRun:[a=>{let h=a.FS.makedev(64,0),x={open:w=>{},close:w=>{},read:(w,U,F,S,b)=>{let se=n(this,D);if(!se)throw new Error("No /dev/blob File or Blob provided to read from");let H=new Uint8Array(se);if(b>=H.length)return 0;let ie=Math.min(H.length-b,S);for(let Q=0;Q<ie;Q++)U[F+Q]=H[b+Q];return ie},write:(w,U,F,S,b)=>(n(this,T)??y(this,T,[]),n(this,T).push(U.slice(F,F+S)),S),llseek:(w,U,F)=>{let S=n(this,D);if(!S)throw new Error("No /dev/blob File or Blob provided to llseek");let b=U;if(F===1?b+=w.position:F===2&&(b=new Uint8Array(S).length),b<0)throw new a.FS.ErrnoError(28);return b}};a.FS.registerDevice(h,x),a.FS.mkdev("/dev/blob",h)}]},{emscriptenOpts:d}=await this.fs.init(this,l);l=d;for(let[a,h]of Object.entries(n(this,z)))if(h instanceof URL)s[a]=ee(h);else{let x=await h.setup(this,l);if(x.emscriptenOpts&&(l=x.emscriptenOpts),x.namespaceObj){let w=this;w[a]=x.namespaceObj}x.bundlePath&&(s[a]=ee(x.bundlePath)),x.init&&o.push(x.init),x.close&&n(this,$).push(x.close)}if(l.pg_extensions=s,await c,this.mod=await we(l),await this.fs.initialSyncFs(),e.loadDataDir){if(this.mod.FS.analyzePath(P+"/PG_VERSION").exists)throw new Error("Database already exists, cannot load from tarball");I(this,E,W).call(this,"pglite: loading data from tarball"),await me(this.mod.FS,e.loadDataDir,P)}this.mod.FS.analyzePath(P+"/PG_VERSION").exists?I(this,E,W).call(this,"pglite: found DB, resuming"):I(this,E,W).call(this,"pglite: no db"),await he(this.mod,(...a)=>I(this,E,W).call(this,...a));let u=this.mod._pg_initdb();if(!u)throw new Error("INITDB failed to return value");if(u&1)throw new Error("INITDB failed");if(u&2){let a=e.username??"postgres",h=e.database??"template1";if(u&4){if(!(u&12))throw new Error("Invalid db/user combination")}else if(h!=="template1"&&a!=="postgres")throw new Error("INITDB created a new datadir, but an alternative db/user was requested")}await this.syncToFs(),y(this,B,!0),await this.exec("SET search_path TO public;"),await this._initArrayTypes();for(let a of o)await a()},W=function(...e){this.debug>0&&console.log(...e)};var be=te;f();export{q as IdbFs,L as MemoryFS,R as Mutex,be as PGlite,Me as formatQuery,Te as messages,_e as parse,Fe as protocol,ve as types,Re as uuid};
//# sourceMappingURL=index.js.map