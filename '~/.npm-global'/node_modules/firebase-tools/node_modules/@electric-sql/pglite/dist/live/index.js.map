{"version":3,"sources":["../../src/live/index.ts"],"sourcesContent":["import type {\n  Extension,\n  PGliteInterface,\n  Results,\n  Transaction,\n} from '../interface'\nimport type {\n  LiveQueryOptions,\n  LiveIncrementalQueryOptions,\n  LiveChangesOptions,\n  LiveNamespace,\n  LiveQuery,\n  LiveChanges,\n  Change,\n} from './interface'\nimport { uuid, formatQuery } from '../utils.js'\n\nexport type {\n  LiveNamespace,\n  LiveQuery,\n  LiveChanges,\n  Change,\n} from './interface.js'\n\nconst MAX_RETRIES = 5\n\nconst setup = async (pg: PGliteInterface, _emscriptenOpts: any) => {\n  // The notify triggers are only ever added and never removed\n  // Keep track of which triggers have been added to avoid adding them multiple times\n  const tableNotifyTriggersAdded = new Set<string>()\n\n  const namespaceObj: LiveNamespace = {\n    async query<T>(\n      query: string | LiveQueryOptions<T>,\n      params?: any[] | null,\n      callback?: (results: Results<T>) => void,\n    ) {\n      let signal: AbortSignal | undefined\n      if (typeof query !== 'string') {\n        signal = query.signal\n        params = query.params\n        callback = query.callback\n        query = query.query\n      }\n      let callbacks: Array<(results: Results<T>) => void> = callback\n        ? [callback]\n        : []\n      const id = uuid().replace(/-/g, '')\n      let dead = false\n\n      let results: Results<T>\n      let tables: { table_name: string; schema_name: string }[]\n\n      const init = async () => {\n        await pg.transaction(async (tx) => {\n          // Create a temporary view with the query\n          const formattedQuery = await formatQuery(pg, query, params, tx)\n          await tx.query(\n            `CREATE OR REPLACE TEMP VIEW live_query_${id}_view AS ${formattedQuery}`,\n          )\n\n          // Get the tables used in the view and add triggers to notify when they change\n          tables = await getTablesForView(tx, `live_query_${id}_view`)\n          await addNotifyTriggersToTables(tx, tables, tableNotifyTriggersAdded)\n\n          // Create prepared statement to get the results\n          await tx.exec(`\n            PREPARE live_query_${id}_get AS\n            SELECT * FROM live_query_${id}_view;\n          `)\n\n          // Get the initial results\n          results = await tx.query<T>(`EXECUTE live_query_${id}_get;`)\n        })\n      }\n      await init()\n\n      // Function to refresh the query\n      const refresh = async (count = 0) => {\n        if (callbacks.length === 0) {\n          return\n        }\n        try {\n          results = await pg.query<T>(`EXECUTE live_query_${id}_get;`)\n        } catch (e) {\n          const msg = (e as Error).message\n          if (\n            msg === `prepared statement \"live_query_${id}_get\" does not exist`\n          ) {\n            // If the prepared statement does not exist, reset and try again\n            // This can happen if using the multi-tab worker\n            if (count > MAX_RETRIES) {\n              throw e\n            }\n            await init()\n            refresh(count + 1)\n          } else {\n            throw e\n          }\n        }\n        runResultCallbacks(callbacks, results)\n      }\n\n      // Setup the listeners\n      const unsubList: Array<() => Promise<void>> = await Promise.all(\n        tables!.map((table) =>\n          pg.listen(\n            `table_change__${table.schema_name}__${table.table_name}`,\n            async () => {\n              refresh()\n            },\n          ),\n        ),\n      )\n\n      // Function to subscribe to the query\n      const subscribe = (callback: (results: Results<T>) => void) => {\n        if (dead) {\n          throw new Error(\n            'Live query is no longer active and cannot be subscribed to',\n          )\n        }\n        callbacks.push(callback)\n      }\n\n      // Function to unsubscribe from the query\n      // If no function is provided, unsubscribe all callbacks\n      // If there are no callbacks, unsubscribe from the notify triggers\n      const unsubscribe = async (callback?: (results: Results<T>) => void) => {\n        if (callback) {\n          callbacks = callbacks.filter((callback) => callback !== callback)\n        } else {\n          callbacks = []\n        }\n        if (callbacks.length === 0) {\n          dead = true\n          await Promise.all(unsubList.map((unsub) => unsub()))\n          await pg.exec(`\n            DROP VIEW IF EXISTS live_query_${id}_view;\n            DEALLOCATE live_query_${id}_get;\n          `)\n        }\n      }\n\n      // If the signal has already been aborted, unsubscribe\n      if (signal?.aborted) {\n        await unsubscribe()\n      } else {\n        // Add an event listener to unsubscribe if the signal is aborted\n        signal?.addEventListener(\n          'abort',\n          () => {\n            unsubscribe()\n          },\n          { once: true },\n        )\n      }\n\n      // Run the callback with the initial results\n      runResultCallbacks(callbacks, results!)\n\n      // Return the initial results\n      return {\n        initialResults: results!,\n        subscribe,\n        unsubscribe,\n        refresh,\n      } satisfies LiveQuery<T>\n    },\n\n    async changes<T>(\n      query: string | LiveChangesOptions<T>,\n      params?: any[] | null,\n      key?: string,\n      callback?: (changes: Array<Change<T>>) => void,\n    ) {\n      let signal: AbortSignal | undefined\n      if (typeof query !== 'string') {\n        signal = query.signal\n        params = query.params\n        key = query.key\n        callback = query.callback\n        query = query.query\n      }\n      if (!key) {\n        throw new Error('key is required for changes queries')\n      }\n      let callbacks: Array<(changes: Array<Change<T>>) => void> = callback\n        ? [callback]\n        : []\n      const id = uuid().replace(/-/g, '')\n      let dead = false\n\n      let tables: { table_name: string; schema_name: string }[]\n      let stateSwitch: 1 | 2 = 1\n      let changes: Results<Change<T>>\n\n      const init = async () => {\n        await pg.transaction(async (tx) => {\n          // Create a temporary view with the query\n          const formattedQuery = await formatQuery(pg, query, params, tx)\n          await tx.query(\n            `CREATE OR REPLACE TEMP VIEW live_query_${id}_view AS ${formattedQuery}`,\n          )\n\n          // Get the tables used in the view and add triggers to notify when they change\n          tables = await getTablesForView(tx, `live_query_${id}_view`)\n          await addNotifyTriggersToTables(tx, tables, tableNotifyTriggersAdded)\n\n          // Get the columns of the view\n          const columns = [\n            ...(\n              await tx.query<any>(`\n                SELECT column_name, data_type, udt_name\n                FROM information_schema.columns \n                WHERE table_name = 'live_query_${id}_view'\n              `)\n            ).rows,\n            { column_name: '__after__', data_type: 'integer' },\n          ]\n\n          // Init state tables as empty temp table\n          await tx.exec(`\n            CREATE TEMP TABLE live_query_${id}_state1 (LIKE live_query_${id}_view INCLUDING ALL);\n            CREATE TEMP TABLE live_query_${id}_state2 (LIKE live_query_${id}_view INCLUDING ALL);\n          `)\n\n          // Create Diff views and prepared statements\n          for (const curr of [1, 2]) {\n            const prev = curr === 1 ? 2 : 1\n            await tx.exec(`\n              PREPARE live_query_${id}_diff${curr} AS\n              WITH\n                prev AS (SELECT LAG(\"${key}\") OVER () as __after__, * FROM live_query_${id}_state${prev}),\n                curr AS (SELECT LAG(\"${key}\") OVER () as __after__, * FROM live_query_${id}_state${curr}),\n                data_diff AS (\n                  -- INSERT operations: Include all columns\n                  SELECT \n                    'INSERT' AS __op__,\n                    ${columns\n                      .map(\n                        ({ column_name }) =>\n                          `curr.\"${column_name}\" AS \"${column_name}\"`,\n                      )\n                      .join(',\\n')},\n                    ARRAY[]::text[] AS __changed_columns__\n                  FROM curr\n                  LEFT JOIN prev ON curr.${key} = prev.${key}\n                  WHERE prev.${key} IS NULL\n                UNION ALL\n                  -- DELETE operations: Include only the primary key\n                  SELECT \n                    'DELETE' AS __op__,\n                    ${columns\n                      .map(({ column_name, data_type, udt_name }) => {\n                        if (column_name === key) {\n                          return `prev.\"${column_name}\" AS \"${column_name}\"`\n                        } else {\n                          return `NULL${data_type === 'USER-DEFINED' ? `::${udt_name}` : ``} AS \"${column_name}\"`\n                        }\n                      })\n                      .join(',\\n')},\n                      ARRAY[]::text[] AS __changed_columns__\n                  FROM prev\n                  LEFT JOIN curr ON prev.${key} = curr.${key}\n                  WHERE curr.${key} IS NULL\n                UNION ALL\n                  -- UPDATE operations: Include only changed columns\n                  SELECT \n                    'UPDATE' AS __op__,\n                    ${columns\n                      .map(({ column_name, data_type, udt_name }) =>\n                        column_name === key\n                          ? `curr.\"${column_name}\" AS \"${column_name}\"`\n                          : `CASE \n                              WHEN curr.\"${column_name}\" IS DISTINCT FROM prev.\"${column_name}\" \n                              THEN curr.\"${column_name}\"\n                              ELSE NULL${data_type === 'USER-DEFINED' ? `::${udt_name}` : ``}\n                              END AS \"${column_name}\"`,\n                      )\n                      .join(',\\n')},\n                      ARRAY(SELECT unnest FROM unnest(ARRAY[${columns\n                        .filter(({ column_name }) => column_name !== key)\n                        .map(\n                          ({ column_name }) =>\n                            `CASE\n                              WHEN curr.\"${column_name}\" IS DISTINCT FROM prev.\"${column_name}\" \n                              THEN '${column_name}' \n                              ELSE NULL \n                              END`,\n                        )\n                        .join(\n                          ', ',\n                        )}]) WHERE unnest IS NOT NULL) AS __changed_columns__\n                  FROM curr\n                  INNER JOIN prev ON curr.${key} = prev.${key}\n                  WHERE NOT (curr IS NOT DISTINCT FROM prev)\n                )\n              SELECT * FROM data_diff;\n            `)\n          }\n        })\n      }\n\n      await init()\n\n      const refresh = async () => {\n        if (callbacks.length === 0 && changes) {\n          return\n        }\n        let reset = false\n        for (let i = 0; i < 5; i++) {\n          try {\n            await pg.transaction(async (tx) => {\n              // Populate the state table\n              await tx.exec(`\n                INSERT INTO live_query_${id}_state${stateSwitch} \n                  SELECT * FROM live_query_${id}_view;\n              `)\n\n              // Get the changes\n              changes = await tx.query<any>(\n                `EXECUTE live_query_${id}_diff${stateSwitch};`,\n              )\n\n              // Switch state\n              stateSwitch = stateSwitch === 1 ? 2 : 1\n\n              // Truncate the old state table\n              await tx.exec(`\n                TRUNCATE live_query_${id}_state${stateSwitch};\n              `)\n            })\n            break\n          } catch (e) {\n            const msg = (e as Error).message\n            if (\n              msg ===\n              `relation \"live_query_${id}_state${stateSwitch}\" does not exist`\n            ) {\n              // If the state table does not exist, reset and try again\n              // This can happen if using the multi-tab worker\n              reset = true\n              await init()\n              continue\n            } else {\n              throw e\n            }\n          }\n        }\n\n        runChangeCallbacks(callbacks, [\n          ...(reset\n            ? [\n                {\n                  __op__: 'RESET' as const,\n                },\n              ]\n            : []),\n          ...changes!.rows,\n        ])\n      }\n\n      // Setup the listeners\n      const unsubList: Array<() => Promise<void>> = await Promise.all(\n        tables!.map((table) =>\n          pg.listen(\n            `table_change__${table.schema_name}__${table.table_name}`,\n            async () => refresh(),\n          ),\n        ),\n      )\n\n      // Function to subscribe to the query\n      const subscribe = (callback: (changes: Array<Change<T>>) => void) => {\n        if (dead) {\n          throw new Error(\n            'Live query is no longer active and cannot be subscribed to',\n          )\n        }\n        callbacks.push(callback)\n      }\n\n      // Function to unsubscribe from the query\n      const unsubscribe = async (\n        callback?: (changes: Array<Change<T>>) => void,\n      ) => {\n        if (callback) {\n          callbacks = callbacks.filter((callback) => callback !== callback)\n        } else {\n          callbacks = []\n        }\n        if (callbacks.length === 0) {\n          dead = true\n          await Promise.all(unsubList.map((unsub) => unsub()))\n          await pg.exec(`\n            DROP VIEW IF EXISTS live_query_${id}_view;\n            DROP TABLE IF EXISTS live_query_${id}_state1;\n            DROP TABLE IF EXISTS live_query_${id}_state2;\n            DEALLOCATE live_query_${id}_diff1;\n            DEALLOCATE live_query_${id}_diff2;\n          `)\n        }\n      }\n\n      // If the signal has already been aborted, unsubscribe\n      if (signal?.aborted) {\n        await unsubscribe()\n      } else {\n        // Add an event listener to unsubscribe if the signal is aborted\n        signal?.addEventListener(\n          'abort',\n          () => {\n            unsubscribe()\n          },\n          { once: true },\n        )\n      }\n\n      // Run the callback with the initial changes\n      await refresh()\n\n      // Fields\n      const fields = changes!.fields.filter(\n        (field) =>\n          !['__after__', '__op__', '__changed_columns__'].includes(field.name),\n      )\n\n      // Return the initial results\n      return {\n        fields,\n        initialChanges: changes!.rows,\n        subscribe,\n        unsubscribe,\n        refresh,\n      } satisfies LiveChanges<T>\n    },\n\n    async incrementalQuery<T>(\n      query: string | LiveIncrementalQueryOptions<T>,\n      params?: any[] | null,\n      key?: string,\n      callback?: (results: Results<T>) => void,\n    ) {\n      let signal: AbortSignal | undefined\n      if (typeof query !== 'string') {\n        signal = query.signal\n        params = query.params\n        key = query.key\n        callback = query.callback\n        query = query.query\n      }\n      if (!key) {\n        throw new Error('key is required for incremental queries')\n      }\n      let callbacks: Array<(results: Results<T>) => void> = callback\n        ? [callback]\n        : []\n      const rowsMap: Map<any, any> = new Map()\n      const afterMap: Map<any, any> = new Map()\n      let lastRows: T[] = []\n      let firstRun = true\n\n      const {\n        fields,\n        unsubscribe: unsubscribeChanges,\n        refresh,\n      } = await namespaceObj.changes<T>(query, params, key, (changes) => {\n        // Process the changes\n        for (const change of changes) {\n          const {\n            __op__: op,\n            __changed_columns__: changedColumns,\n            ...obj\n          } = change as typeof change & { [key: string]: any }\n          switch (op) {\n            case 'RESET':\n              rowsMap.clear()\n              afterMap.clear()\n              break\n            case 'INSERT':\n              rowsMap.set(obj[key], obj)\n              afterMap.set(obj.__after__, obj[key])\n              break\n            case 'DELETE': {\n              const oldObj = rowsMap.get(obj[key])\n              rowsMap.delete(obj[key])\n              // null is the starting point, we don't delete it as another insert\n              // may have happened thats replacing it\n              if (oldObj.__after__ !== null) {\n                afterMap.delete(oldObj.__after__)\n              }\n              break\n            }\n            case 'UPDATE': {\n              const newObj = { ...(rowsMap.get(obj[key]) ?? {}) }\n              for (const columnName of changedColumns) {\n                newObj[columnName] = obj[columnName]\n                if (columnName === '__after__') {\n                  afterMap.set(obj.__after__, obj[key])\n                }\n              }\n              rowsMap.set(obj[key], newObj)\n              break\n            }\n          }\n        }\n\n        // Get the rows in order\n        const rows: T[] = []\n        let lastKey: any = null\n        for (let i = 0; i < rowsMap.size; i++) {\n          const nextKey = afterMap.get(lastKey)\n          const obj = rowsMap.get(nextKey)\n          if (!obj) {\n            break\n          }\n          // Remove the __after__ key from the exposed row\n          const cleanObj = { ...obj }\n          delete cleanObj.__after__\n          rows.push(cleanObj)\n          lastKey = nextKey\n        }\n        lastRows = rows\n\n        // Run the callbacks\n        if (!firstRun) {\n          runResultCallbacks(callbacks, {\n            rows,\n            fields,\n          })\n        }\n      })\n\n      firstRun = false\n      runResultCallbacks(callbacks, {\n        rows: lastRows,\n        fields,\n      })\n\n      const subscribe = (callback: (results: Results<T>) => void) => {\n        callbacks.push(callback)\n      }\n\n      const unsubscribe = async (callback?: (results: Results<T>) => void) => {\n        if (callback) {\n          callbacks = callbacks.filter((callback) => callback !== callback)\n        } else {\n          callbacks = []\n        }\n        if (callbacks.length === 0) {\n          await unsubscribeChanges()\n        }\n      }\n\n      if (signal?.aborted) {\n        await unsubscribe()\n      } else {\n        signal?.addEventListener(\n          'abort',\n          () => {\n            unsubscribe()\n          },\n          { once: true },\n        )\n      }\n\n      return {\n        initialResults: {\n          rows: lastRows,\n          fields,\n        },\n        subscribe,\n        unsubscribe,\n        refresh,\n      } satisfies LiveQuery<T>\n    },\n  }\n\n  return {\n    namespaceObj,\n  }\n}\n\nexport const live = {\n  name: 'Live Queries',\n  setup,\n} satisfies Extension\n\nexport type PGliteWithLive = PGliteInterface<{\n  live: typeof live\n}>\n\n/**\n * Get a list of all the tables used in a view, recursively\n * @param tx a transaction or PGlite instance\n * @param viewName the name of the view\n * @returns list of tables used in the view\n */\nasync function getTablesForView(\n  tx: Transaction | PGliteInterface,\n  viewName: string,\n): Promise<{ table_name: string; schema_name: string }[]> {\n  const tables = new Map<string, { table_name: string; schema_name: string }>()\n\n  async function getTablesRecursive(currentViewName: string) {\n    const result = await tx.query<{\n      table_name: string\n      schema_name: string\n      is_view: boolean\n    }>(\n      `\n        SELECT DISTINCT\n          cl.relname AS table_name,\n          n.nspname AS schema_name,\n          cl.relkind = 'v' AS is_view\n        FROM pg_rewrite r\n        JOIN pg_depend d ON r.oid = d.objid\n        JOIN pg_class cl ON d.refobjid = cl.oid\n        JOIN pg_namespace n ON cl.relnamespace = n.oid\n        WHERE\n        r.ev_class = (\n            SELECT oid FROM pg_class WHERE relname = $1 AND relkind = 'v'\n        )\n        AND d.deptype = 'n';\n      `,\n      [currentViewName],\n    )\n\n    for (const row of result.rows) {\n      if (row.table_name !== currentViewName && !row.is_view) {\n        const tableKey = `\"${row.schema_name}\".\"${row.table_name}\"`\n        if (!tables.has(tableKey)) {\n          tables.set(tableKey, {\n            table_name: row.table_name,\n            schema_name: row.schema_name,\n          })\n        }\n      } else if (row.is_view) {\n        await getTablesRecursive(row.table_name)\n      }\n    }\n  }\n\n  await getTablesRecursive(viewName)\n\n  return Array.from(tables.values())\n}\n\n/**\n * Add triggers to tables to notify when they change\n * @param tx a transaction or PGlite instance\n * @param tables list of tables to add triggers to\n */\nasync function addNotifyTriggersToTables(\n  tx: Transaction | PGliteInterface,\n  tables: { table_name: string; schema_name: string }[],\n  tableNotifyTriggersAdded: Set<string>,\n) {\n  const triggers = tables\n    .filter(\n      (table) =>\n        !tableNotifyTriggersAdded.has(\n          `${table.schema_name}_${table.table_name}`,\n        ),\n    )\n    .map((table) => {\n      return `\n      CREATE OR REPLACE FUNCTION \"_notify_${table.schema_name}_${table.table_name}\"() RETURNS TRIGGER AS $$\n      BEGIN\n        PERFORM pg_notify('table_change__${table.schema_name}__${table.table_name}', '');\n        RETURN NULL;\n      END;\n      $$ LANGUAGE plpgsql;\n      CREATE OR REPLACE TRIGGER \"_notify_trigger_${table.schema_name}_${table.table_name}\"\n      AFTER INSERT OR UPDATE OR DELETE ON \"${table.schema_name}\".\"${table.table_name}\"\n      FOR EACH STATEMENT EXECUTE FUNCTION \"_notify_${table.schema_name}_${table.table_name}\"();\n      `\n    })\n    .join('\\n')\n  if (triggers.trim() !== '') {\n    await tx.exec(triggers)\n  }\n  tables.map((table) =>\n    tableNotifyTriggersAdded.add(`${table.schema_name}_${table.table_name}`),\n  )\n}\n\nconst runResultCallbacks = <T>(\n  callbacks: Array<(results: Results<T>) => void>,\n  results: Results<T>,\n) => {\n  for (const callback of callbacks) {\n    callback(results)\n  }\n}\n\nconst runChangeCallbacks = <T>(\n  callbacks: Array<(changes: Array<Change<T>>) => void>,\n  changes: Array<Change<T>>,\n) => {\n  for (const callback of callbacks) {\n    callback(changes)\n  }\n}\n"],"mappings":"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","names":["init_esm_shims","MAX_RETRIES","setup","pg","_emscriptenOpts","tableNotifyTriggersAdded","namespaceObj","query","params","callback","signal","callbacks","id","uuid","dead","results","tables","init","tx","formattedQuery","formatQuery","getTablesForView","addNotifyTriggersToTables","refresh","count","e","runResultCallbacks","unsubList","table","subscribe","unsubscribe","unsub","key","stateSwitch","changes","columns","curr","prev","column_name","data_type","udt_name","reset","i","runChangeCallbacks","field","rowsMap","afterMap","lastRows","firstRun","fields","unsubscribeChanges","change","op","changedColumns","obj","oldObj","newObj","columnName","rows","lastKey","nextKey","cleanObj","live","viewName","getTablesRecursive","currentViewName","result","row","tableKey","triggers"]}